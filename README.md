# exAll

## 스트래티지 패턴

* **행위를 클래스로 캡슐화**해 동적으로 행위를 자유롭게 바꿀 수 있게 해주는 패턴
* 여러 알고리즘을 하나의 추상적인 접근점을 만들어 접근 점에서 서로 교환가능하도록 하는 패턴

### Case A
* 인터페이스 - 기능의 구현 분리 및 기능사용의 통로 ex) Sword 객체에서의  implements Weapon 
* 델리게이트 - 객체 구현을 다른곳으로 떠넘기는 방식 ex) GameCharacter의 weapon.attack();
* 풀이 - Weapon이라는 접합점을 가지고 attack선언만 하고 실제 axe,knife,sword에서 attack을 구현
그리고 GameCharacter에서 axe,knife,sword를 세팅한다.

### Case B
#### 문제점
* 기존 로봇의 공격 또는 이동 방법을 수정하려면 어떤 변경작업을 해야 하는가? 예를 들어 아톰이 날 수는 없고 오직 걷게만 만들고 싶다면?
또는 태권V를 날게 하려면?

    - 가령 아톰이 날 수는 없고 오직 걷게만 만들고 싶다면 아래와 같이 변경 해야한다. 
    
    ```java
    public void move() {
      System.out.println("I can only walk.");
    }
    ```
    이는 새로운 기능으로 변경하려고 기존 코드의 내용을 수정해야 하므로 OCP에 위배된다. 또한 Atom클래스의 move
    메서드와 TaekwonV 클래스의 move메서드가 동일한 기능을 실행하므로 기능이 중복되는 상황이 발생한다.
    로봇의 종류가 많아질 수록 이와같은 방식은 매우 높은 수준의 집중력을 요구한다.
    
* 새로운 로봇을 만들어 기존의 공격 또는 이동 방법을 추가하거나 수정하려면? 예를 들어 새로운 로봇으로 지구의
용사 선가드(SunGard 클래스)를 만들어 태권V의 미사일 공격 기능을 추가 하려면?
    - 현재 설계는 로봇 자체가 캡슐화 단위이므로 새로운 로봇을 추가하기가 매우 쉽다.그러나 선가드 클래스가 태권V의 미사일
    공격기능을 사용하려고 하면 또다시 메소드 중복이 일어난다. 이는 나중에 심각한 문제를 일으킬 수 있다.

#### 해결책
* 무엇이 변화되었는지 찾아야 한다. 변화된 것을 찾은 후에는 이를 클래스로 캡슐화 해야한다.
로봇 예제에서 문제를 발생시키는 요인은 로봇의 이동 방식과 공격 방식의 변화다. 즉 새로운 방식의 이동 및 공격 기능이 계속해서 
추가될 수 있으므로 기존의 로봇이나 새로운 로봇이 이러한 기능을 별다른 코드 변경 없이 제공받거나
기존의 공격이나 이동 방식을 다른 공격이나 이동 방식으로 쉽게 변경할 수 있어야 한다.
    > 무엇이 변화되었는지를 찾은 후에 이를 클래스로 캡슐화 한다.

* Case B - answer : MovingStrategy는 이동기능을 캡슐화, AttackStrategy는 공격 기능을 캡슐화